{"domain":"javascript.info","idMap":{},"files":[{"path":"01-document","children":[{"path":"01-document/01-events","children":[{"path":"01-document/01-events/01-introduction-browser-events.md","data":"# Introduction into browser events\u000a\u000aMost JavaScript-applications perform actions as a response to <em>events</em>.\u000a\u000aAn <em>event</em> is a signal from the browser that something has happened.\u000a\u000a=Cut\u000a\u000aThere are many types of events.\u000a\u000a<ul>\u000a <li>DOM events, which are initiated by DOM-elements. For instance, a `click` event happens when an element is clicked, a `mouseover` - when a mouse pointer comes over an element,</li>\u000a <li>Window events. For instance, `resize` - when a browser window is resized,</li>\u000a <li>Other events, like `load`, `readystatechange`. They are used in AJAX and for other needs.</li>\u000a</ul>\u000a\u000aDOM events connect JavaScript code with the document, providing the means for building dynamical interfaces.\u000a\u000a## Assigning event handlers\u000a\u000aFor a script to react on the event, there should be a function assigned to it.\u000a\u000aFunctions which react on events are called <i>event handlers</i>. They are usually named like `\"on+event type\"`, for instance: `onclick`.\u000a\u000a[smart]\u000aJavaScript event handling is single-threaded, so handlers are executed sequentially. \u000aThat means, if two events happen simultanteously, for example `mouseover` (mouse has come over an element) and `mousemove` (mouse moved over an element), their handlers will be executed one after another.\u000a[/smart]\u000a\u000aThere are several ways of assigning an event handler. All of them are given in details below.\u000a\u000a<h3>Using a attribute of HTML-tag</h3>\u000a\u000aA handler can be set directly in the markup, right into the attribute named `on<em>event</em>`.\u000a\u000aFor example, to process a `click` event on the `input` button, it is possible to assign an `onclick` handler like this:\u000a\u000a[html]\u000a<input id=\"b1\" value=\"Click me\" onclick=\"alert('Thanks!');\" type=\"button\"/>\u000a[/html]\u000a\u000aIn action:\u000a\u000a<input id=\"b1\" value=\"Click me\" onclick=\"alert('Thanks!');\" type=\"button\"/>\u000aThe last example uses <i>single quotes inside double quotes</i>. An often newbie mistake is to forget that the code is inside an attribute.\u000a\u000aUsing them like `onclick=\"alert(\"Click\")\"` won't work. If you really need it, try `onclick=\"alert(&quot;Click&quot;)\"`. But usually you don't. Read on for more event handling methods.\u000a\u000aIt is also possible to call a function for the event handling.\u000aThe example below runs a function `count_rabbits()` if a button is clicked.\u000a\u000a[html src=\"assets/2.html\" run height=80][/html]\u000a\u000aPlease recall that HTML-tag attribute names are case-insensitive, so `oNcLiCk` will work same as `onClick` or `onclick`.\u000a\u000aBut it is generally considered a good style to use lowercase.\u000a\u000a<h4>When to use this method</h4>\u000a\u000aThis way of assigning handlers is very convenient - it's simple and all-inline, that's why it is sometimes used for really simple tasks.\u000a\u000aThere are certain drawbacks of this method. When a handler becomes longer than one line - readability suffers greatly.\u000a\u000aBut, after all, no one writes somewhat complex handlers in HTML. Instead of it, use JavaScript-only ways which are described in the next subsection.\u000a\u000a<ul class=\"balance\">\u000a<li class=\"list-plus\">A simple way for simple tasks</li>\u000a<li class=\"list-minus\">Mixed JavaScript-code and HTML-markup</li>\u000a<li class=\"list-minus\">Difficult to write complex handlers</li>\u000a</ul>\u000a\u000a\u000a<h3>The element is `this`</h3>\u000a\u000aAlthough usage of this event-binding method is not recommended, let's demonstrate the value of `this` with it.\u000a\u000a<b>Inside an event handler, `this` references the current element.</b> It can be used to get properties on modify the element.\u000a\u000aBelow, the `button` outputs it's contents using `this.innerHTML`:\u000a\u000a[html height=auto autorun]\u000a<button onclick=\"alert(this.innerHTML)\">Click me to see me</button>\u000a[/html]\u000a\u000a\u000a<h3>Using a DOM-object property</h3>\u000a\u000aA closest relative of the way described above - is an assignment using the property named `on<em>event</em>`.\u000a\u000aAll you need is:\u000a<ol>\u000a<li>To get an element</li>\u000a<li>To assign a handler to the property `on<em>event</em>`</li>\u000a</ol>\u000a\u000aHere is an example of setting a `click` handler to the element with  `id=&quot;myElement&quot;`:\u000a\u000a[html]\u000a<input id=\"myElement\" type=\"button\" value=\"Press me\"/>\u000a<script>\u000adocument.getElementById('myElement').onclick = function() {\u000a    alert('Thanks')\u000a}\u000a</script>\u000a[/html]\u000a\u000aIn action:\u000a<input id=\"myElement\" type=\"button\" value=\"Press me\"/>\u000a<script>\u000adocument.getElementById('myElement').onclick = function() {\u000a    alert('Thanks')\u000a}\u000a</script>\u000a\u000aPlease, note the two details:\u000a<ol>\u000a <li>It is a property, not an attribute. The name of the property is `on<i>event</i>`, case-sensitive and must be <i>lowercased</i>. `onClick` won't work.\u000a </li>\u000a <li>The handler must be a function, not a string.\u000a</li>\u000a</ol>\u000a\u000aWhen the browser meets an `on...` attribute in HTML-markup - it basically creates a function from its contents and assigns it to the property.\u000a\u000aSo these two codes do the same:\u000a\u000a<ol>\u000a<li>Only HTML:\u000a[html run height=50]\u000a<input type=\"button\" onclick=\"alert('Click!')\" value=\"Button\"/>\u000a[/html]\u000a</li>\u000a<li>HTML + JS:\u000a[html run height=50]\u000a<input type=\"button\" id=\"button\" value=\"Button\"/>\u000a<script>\u000a document.getElementById('button').onclick = function() {\u000a     alert('Click!')\u000a }\u000a</script>\u000a[/html]\u000a</li>\u000a</ol>\u000a\u000aIf there is a handler set in markup, the script overwrites it. In the example below, JavaScript replaces a markup handler with a new one.\u000a\u000a[html run height=50]\u000a<input type=\"button\" onclick=\"alert('Before')\" value=\"Press me\"/>\u000a<script>\u000adocument.getElementsByTagName('input')[0].onclick = function() {\u000a  alert('After')\u000a}\u000a</script>\u000a[/html]\u000a\u000aOf course, it is possible to use an existing function:\u000a\u000a[js]\u000afunction doSomething() {\u000a  alert('Thanks!')\u000a}\u000a\u000adocument.getElementById('button').onclick = doSomething\u000a[/js]\u000a\u000a[smart header=\"An often newbie mistake\"]\u000aPlease, note that the function should be assigned, namely `doSomething`, not `doSomething()`:\u000a\u000a[js]\u000adocument.getElementById('button').onclick = doSomething\u000a[/js]\u000a\u000a`doSomething()` - is a result of function execution, and because there is no `return` in it, the result will be `undefined`.\u000a\u000aCompare it against an attribute. Brackets are required there:\u000a[html]\u000a<input type=\"button\" id=\"button\" onclick=\"doSomething()\"/>\u000a[/html]\u000a\u000aThe difference is easy to explain. When the browser comes across `onclick` attribute, it automatically creates a function from its contents. So the last example is basically same as:\u000a[js]\u000adocument.getElementById('button').onclick = function() {\u000a  doSomething()  // an autocreated function\u000a}\u000a[/js]\u000a\u000a[/smart]\u000a\u000a<h4>When to use</h4>\u000a\u000aAssiging handlers using a property is a very simple and popular way.\u000a\u000aIt has a problem: only one handler for a certain event type can be set.\u000a\u000aFor example:\u000a[js]\u000ainput.onclick = function() { alert(1) }\u000a// ...\u000ainput.onclick = function() { alert(2) } // replaces the previous handler\u000a[/js]\u000a\u000a<ol class=\"balance\">\u000a<li class=\"plus\">A convenient and reliable way, works in JavaScript</li>\u000a<li class=\"minus\">A single handler per event</li>\u000a</ol>\u000a\u000aOf course, it's possible to copy old handler and run it manually inside a new one. But it is better to use more advanced methods of assignment.\u000a\u000a\u000a<h3>Special methods</h3>\u000a\u000aIn a complex javascript application, it's fairly ok that different interface components may be interested in handling the same event.\u000a\u000aA classical example is a \"document loaded\" event and many graphical components which wait for it to initialize themselves.\u000a\u000a<h4>Microsoft solution</h4>\u000a\u000aThe solution provided by Microsoft and used only in Internet Explorer less than `9`.\u000a\u000aIt is also supported by Opera for compatibility, but no one uses it there, because Opera also supports another standard-compliant method (see in the next section).\u000a\u000aAssigning a handler:\u000a[js]\u000aelement.attachEvent( \"on\"+event, handler)\u000a[/js]\u000a\u000aRemoving a handler:\u000a[js]\u000aelement.detachEvent( \"on\"+event, handler)\u000a[/js]\u000a\u000aFor instance:\u000a[js]\u000avar input = document.getElementById('button')\u000afunction handler() {\u000a    alert('Thanks!')\u000a}\u000ainput.attachEvent( \"onclick\" , handler) // assign the handler\u000a// ....\u000ainput.detachEvent( \"onclick\", handler) // remove the handler\u000a[/js]\u000a\u000a[smart header=\"An often newbie mistake\"]\u000aPlease, note - setting and removal methods need the same `handler` object to operate correctly.\u000a\u000aThis would be wrong:\u000a[js]\u000ainput.attachEvent( \"onclick\" ,\u000a   function() {alert('Thanks')}\u000a)\u000a// ....\u000ainput.detachEvent( \"onclick\",\u000a   function() {alert('Thanks')}\u000a)\u000a[/js]\u000a\u000aIn the example below, there are actually two different function objects.\u000a\u000aSo if it is planned to remove the handler sometime, the reference to it should be stored somewhere.\u000a[/smart]\u000a\u000aUsing `attachEvent`, it is possible to assign multiple handlers to the same event on same element. The example below will work only <u>in IE and Opera</u>:\u000a\u000a[html run]\u000a<input id=\"myElement\" type=\"button\" value=\"Press me\"/>\u000a\u000a<script>\u000a  var myElement = document.getElementById(\"myElement\")\u000a  var handler = function() {\u000a    alert('Thanks!')\u000a  }\u000a\u000a  var handler2 = function() {\u000a    alert('Thanks again!')\u000a  }\u000a\u000a  myElement.attachEvent(\"onclick\", handler)\u000a  myElement.attachEvent(\"onclick\", handler2)\u000a</script>\u000a[/html]\u000a\u000a\u000a[warn header=\"attachEvent does not pass `this`\"]\u000aThe exception is `attachEvent` method. Handlers assigned with `attachEvent` do not have `this`!\u000a[/warn]\u000a\u000a\u000a<h4>Handlers assignment by W3C standard</h4>\u000a\u000aW3C or official event handler assignment works in all modern browsers and for IE9.\u000a\u000aAssigning a handler:\u000a[js]\u000aelement.addEventListener( event, handler, phase)\u000a[/js]\u000a\u000aRemoving a handler:\u000a[js]\u000aelement.removeEventListener( event, handler, phase)\u000a[/js]\u000a\u000aPlease, note that the event name goes without the \"on\" prefix.\u000a\u000aAnother difference from the Microsoft syntax is the third parameter - <i>phase</i>, which is usually not used and set to `false`.\u000a\u000aThe usage is generally same as `attachEvent`:\u000a[js]\u000a// ... declare a function called handler ...\u000aelem.addEventListener( \"click\" , handler, false) // assign the handler\u000a// ....\u000aelem.removeEventListener( \"click\", handler, false) // remove the handler\u000a[/js]\u000a\u000aSo, there is a one big plus and one minus of the special methods:\u000a\u000a<ol class=\"balance\">\u000a<li class=\"plus\">As many handlers as you want</li>\u000a<li class=\"minus\">Cross-browser incompatibilities</li>\u000a</ol>\u000a\u000aThe incompatibilities is not just different syntax, but there are few other differences. We'll return to it in the next sections and discuss a cross-browser method of event handling.\u000a\u000a\u000a\u000a<h3>Handlers order</h3>\u000a\u000aSpecial methods allow to assign multiple handlers to the same event on single object.\u000a\u000aBrowser does not guarantee the order in which they execute.\u000a\u000aGenerally, the order of assignment is not related with the order of execution. The order may happen to be same, or inversed or random.\u000a\u000a\u000a<h3>A cross-browser way of assigning event handlers</h3>\u000a\u000aThe task is not so simple as it seems.\u000a\u000aThere simplest and mostly working solution is to create custom functions which add and remove event handlers using special methods:\u000a\u000a[js]\u000aif (document.addEventListener) {\u000a    var addEvent = function(elem, type, handler) {\u000a        elem.addEventListener(type, handler, false)\u000a    }\u000a    var removeEvent = function(elem, type, handler) {\u000a        elem.removeEventListener(type, handler, false)\u000a    }\u000a} else {\u000a    var addEvent = function(elem, type, handler) {\u000a        elem.attachEvent(\"on\" + type, handler)\u000a    }\u000a    var removeEvent = function(elem, type, handler) {\u000a        elem.detachEvent(\"on\" + type, handler)\u000a    }\u000a}\u000a\u000a...\u000aaddEvent(elem, \"click\", function() { alert('hi') })\u000a[/js]\u000a\u000aIt works good in most cases, but the handler will lack `this` in IE, because `attachEvent` doesn't provide `this`.\u000a\u000aFixing this problem may look easy, but it actually isn't, because of advanced topics like IE&lt;8 memory leaks.\u000a\u000aBut you don't need `this` and don't care about memory leaks, then the solution is simple and works well.\u000a\u000a[task src=\"task/hide-on-click.md\"]\u000a\u000a\u000a<h2>Summary</h2>\u000a\u000a\u000aThere are 3 ways of assigning event handlers: markup, `on<i>event</i>` and special methods.\u000a\u000a\u000a=Head\u000a\u000a<style>\u000a  @import url(\"events.css\");\u000a</style>\u000a<script>\u000afunction highlightMe(elem) {\u000a    elem.style.backgroundColor='yellow';\u000a    alert(elem.className);\u000a    elem.style.backgroundColor = '';\u000a}\u000a\u000afunction highlightMe2(e) {\u000a    highlightMe(e.currentTarget);\u000a}\u000a</script>\u000a\u000a","title":"Introduction into browser events"}],"data":"# Events\u000a\u000a[#events-ref]","title":"Events"}],"data":"\u000a# Documents and Events","title":"Documents and Events"}]}